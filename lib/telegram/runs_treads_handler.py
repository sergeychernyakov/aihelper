import time
import random
import json
from lib.telegram.answer import Answer
from lib.telegram.helpers import Helpers
from db.models.conversation import Conversation
from lib.telegram.image import Image
from lib.telegram.email_sender import EmailSender
from lib.telegram.tokenizer import Tokenizer
from datetime import timedelta
from decimal import Decimal
from lib.telegram.payment import Payment
from lib.localization import _

class RunsTreadsHandler:

    MAX_RUN_DURATION = 60*60

    def __init__(self, openai_client, update, context, conversation, session, chat_id):
        self.openai = openai_client
        self.update = update
        self.context = context
        self.session = session
        self.conversation = conversation
        self.thread_id = conversation.thread_id
        self.assistant_id = conversation.assistant_id
        self.answer = Answer(openai_client, context, chat_id, self.thread_id)
        self.tokenizer = Tokenizer()
        self.thread_recreation_interval = timedelta(hours=1)
        self.payment = Payment()

    ######## Work with OpenAI threads, runs #########   class RunsTreadsHandler
    async def create_run(self):
        """
        Create and manage a run for a specific thread in the OpenAI API.

        This method initiates a run, waits for its completion, and processes
        the messages received from the API, including text and image responses.
        It also handles balance updates based on the response content.
        """
        run = self.openai.beta.threads.runs.create(
            thread_id=self.thread_id,
            assistant_id=self.assistant_id
        )

        start_time = time.time()  # Record the start time of the run

        while run.status != "completed":
            time.sleep(3)
            run = self.openai.beta.threads.runs.retrieve(
                thread_id=self.thread_id,
                run_id=run.id
            )

            if run.status == 'requires_action':
                await self.submit_tool_outputs(run)

            # Check if the maximum run duration is exceeded
            if time.time() - start_time > self.MAX_RUN_DURATION:
                print("!!!!!! Run exceeded maximum duration, cancelling...")
                self.cancel_run(self.thread_id, run.id)
                break

        # List messages from the thread
        messages = self.openai.beta.threads.messages.list(
            thread_id=self.thread_id
        )

        # Process each content in the first message
        for content in messages.data[0].content:
            if content.type == 'text':
                response_text = content.text.value
                print(f'AI responded: {response_text}')

                # Decrease balance for output text
                amount = self.tokenizer.tokens_to_money_from_string(response_text, "output")
                print(f'---->>> Conversation balance decreased by: {amount} for output text')
                self.conversation.balance -= amount

                # Define a threshold for a short message
                short_message_threshold = 100
                if len(response_text) <= short_message_threshold: #and random.randint(1, 10) == 1:
                    await self.answer.answer_with_voice(response_text)

                    # Update the balance for output voice
                    amount = self.tokenizer.tokens_to_money_to_voice(response_text)
                    print(f'---->>> Conversation balance decreased by: {amount} for output voice')
                    self.conversation.balance -= amount
                else:
                    await self.answer.answer_with_text(response_text)

                # Check for annotations and send document if present
                if 'annotations' in content.text:
                    # Decrease balance for output document
                    amount = Decimal(0.001)
                    print(f'---->>> Conversation balance decreased by: {amount} for document generated by AI.')
                    self.conversation.balance -= amount

                    annotation_data = content.text.annotations[0]
                    await self.answer.answer_with_annotation(annotation_data)

            elif content.type == 'image_file':
                # Decrease balance for output text
                amount = self.tokenizer.tokens_to_money_to_image()
                print(f'---->>> Conversation balance decreased by: {amount} for image generated by AI.')
                self.conversation.balance -= amount

                # Send image if the content type is 'image_file'
                file_id = content.image_file.file_id
                await self.answer.answer_with_image(file_id)

        return run.id

    def create_thread(self, session, conversation):
        thread = self.openai.beta.threads.create()
        self.thread_id = thread.id
        conversation.thread_id = thread.id
        session.query(Conversation).filter_by(id=conversation.id).update({"thread_id": thread.id})
        session.commit()

    def recreate_thread(self, session, conversation):
        self.openai.beta.threads.delete(conversation.thread_id)
        self.create_thread(session, conversation)

    def cancel_run(self, thread_id, run_id):
        # Check if both thread_id and run_id are present and not None
        if thread_id and run_id:
            try:
                # Attempt to cancel the run
                run = self.openai.beta.threads.runs.cancel(
                    thread_id=thread_id,
                    run_id=run_id
                )
                # Add any additional logic here if needed, e.g., logging the cancellation
            except Exception as e:
                # Handle exceptions, e.g., log an error message
                print(f"Error occurred while cancelling the run: {e}")
        else:
            # Handle the case where thread_id or run_id is missing
            print("Cannot cancel run: Missing thread_id or run_id.")

    async def submit_tool_outputs(self, run):
        tool_outputs = []

        for tool_call in run.required_action.submit_tool_outputs.tool_calls:
            tool_call_id = tool_call.id  # Access the id attribute
            function_name = tool_call.function.name  # Access the function name attribute
            arguments = tool_call.function.arguments  # Access the arguments attribute

            # Parse arguments if it's a JSON string
            args = json.loads(arguments)
            # Handle different function calls
            if function_name == 'generateImage':
                output = await self._generate_image(tool_call_id, args)
            elif function_name == 'sendEmail':
                output = self._send_email(tool_call_id, args)
            else:
                # Handle other function calls or throw an error
                output = {
                    "tool_call_id": tool_call_id,
                    "output": '',
                }

            tool_outputs.append(output)

        # Submit tool outputs back to the OpenAI API
        self.openai.beta.threads.runs.submit_tool_outputs(
            thread_id=self.thread_id,
            run_id=run.id,
            tool_outputs=tool_outputs
        )

    # private

    # Functions
    def _send_email(self, tool_call_id, args):
        sender = EmailSender(self.openai)
        attachment = 'attachment'
        sender.send_email(args['email'], args['text'], attachment)
        self.context.bot.send_message(self.update.message.chat_id, _('Letter successfully sent.'))
        return {
            "tool_call_id": tool_call_id,
            "output": _('Letter successfully sent. There is no need to reply to the message.')
        }

    async def _generate_image(self, tool_call_id, args):
        # Check if the balance is sufficient
        amount = self.tokenizer.tokens_to_money_from_string(args['description'])
        amount += self.tokenizer.tokens_to_money_to_image()
        if not self.tokenizer.has_sufficient_balance_for_amount(amount, self.conversation.balance):
            message = _("Insufficient balance to process the generating image.")
            print(message)
            await self.context.bot.send_message(self.update.message.chat_id, message)
            await self.payment.send_invoice(self.update, self.context, False)
            return False, message

        # Assuming Image class has a generateImage method
        image = Image(self.openai)
        image_url, revised_prompt = image.generate(args['description'])  # Pass the description argument

        # Update the balance
        amount += self.tokenizer.tokens_to_money_from_string(revised_prompt)
        print(f'---->>> Conversation balance decreased by: ${amount} for generating image.')
        self.conversation.balance -= amount

        await self.context.bot.send_photo(self.update.message.chat_id, image_url) # in some cases AI answers with wrong image url without params
        return {
            "tool_call_id": tool_call_id,
            "output": f'{image_url} - this picture has already been sent to the user in the Telegram chat. There is no need to reply to the message.'
        }
